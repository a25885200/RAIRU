<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Remote Control Software Demo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.23.0/ace.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.23.0/mode-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.23.0/theme-monokai.min.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        secondary: '#4F4FD9',
                        dark: {
                            bg: '#181818',
                            card: '#252525',
                            border: '#333333'
                        },
                        light: {
                            bg: '#FFFFFF',
                            card: '#F5F5F5',
                            border: '#E5E5E5'
                        }
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-light-bg dark:bg-dark-bg text-gray-800 dark:text-gray-200 min-h-screen">
    <!-- Dark mode detection -->
    <script>
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });
    </script>

    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <h1 class="text-3xl font-bold text-center mb-6">Python Remote Control Software</h1>
        
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
            <!-- Connection Panel -->
            <div class="bg-light-card dark:bg-dark-card p-4 rounded-lg shadow-md border border-light-border dark:border-dark-border">
                <h2 class="text-xl font-semibold mb-4">Connection</h2>
                <div class="space-y-3">
                    <div>
                        <label for="host" class="block mb-1">Remote Host</label>
                        <input type="text" id="host" value="192.168.1.100" class="w-full px-3 py-2 text-base rounded border border-gray-300 dark:border-gray-600 bg-white dark:bg-dark-bg focus:outline-none focus:ring-2 focus:ring-primary">
                    </div>
                    <div>
                        <label for="port" class="block mb-1">Port</label>
                        <input type="text" id="port" value="5000" class="w-full px-3 py-2 text-base rounded border border-gray-300 dark:border-gray-600 bg-white dark:bg-dark-bg focus:outline-none focus:ring-2 focus:ring-primary">
                    </div>
                    <div>
                        <label for="password" class="block mb-1">Password</label>
                        <input type="password" id="password" value="••••••••" class="w-full px-3 py-2 text-base rounded border border-gray-300 dark:border-gray-600 bg-white dark:bg-dark-bg focus:outline-none focus:ring-2 focus:ring-primary">
                    </div>
                    <div>
                        <label for="encryption" class="block mb-1">Encryption</label>
                        <select id="encryption" class="w-full px-3 py-2 text-base rounded border border-gray-300 dark:border-gray-600 bg-white dark:bg-dark-bg focus:outline-none focus:ring-2 focus:ring-primary">
                            <option>AES-256</option>
                            <option>TLS 1.3</option>
                            <option>SSH Tunnel</option>
                        </select>
                    </div>
                    <div class="pt-2">
                        <button id="connect-btn" class="w-full bg-primary hover:bg-secondary text-white font-medium py-2 px-4 rounded transition-colors">
                            Connect
                        </button>
                    </div>
                    <div id="connection-status" class="text-sm font-medium text-red-500 mt-2">
                        Disconnected
                    </div>
                </div>
            </div>

            <!-- Remote Screen Panel -->
            <div class="lg:col-span-2 bg-light-card dark:bg-dark-card p-4 rounded-lg shadow-md border border-light-border dark:border-dark-border overflow-hidden">
                <h2 class="text-xl font-semibold mb-4">Remote Screen</h2>
                <div id="remote-screen" class="relative bg-gray-800 rounded overflow-hidden h-[40vh] lg:h-[30vh] flex items-center justify-center">
                    <div id="screen-message" class="text-center text-gray-400">
                        <p class="text-lg mb-2">Not connected</p>
                        <p class="text-sm">Connect to a remote machine to view screen</p>
                    </div>
                    <div id="remote-desktop" class="hidden w-full h-full">
                        <div class="bg-blue-900 w-full h-full p-4">
                            <div class="flex items-center mb-4">
                                <div class="bg-white rounded-full w-8 h-8 flex items-center justify-center mr-2">
                                    <span class="text-blue-900 font-bold">W</span>
                                </div>
                                <span class="text-white">Windows Remote Desktop</span>
                            </div>
                            <div class="grid grid-cols-6 gap-2">
                                <div class="bg-white bg-opacity-20 p-2 rounded">
                                    <div class="w-full h-4 bg-white bg-opacity-40 rounded mb-1"></div>
                                    <div class="w-3/4 h-3 bg-white bg-opacity-30 rounded"></div>
                                </div>
                                <div class="bg-white bg-opacity-20 p-2 rounded">
                                    <div class="w-full h-4 bg-white bg-opacity-40 rounded mb-1"></div>
                                    <div class="w-3/4 h-3 bg-white bg-opacity-30 rounded"></div>
                                </div>
                                <div class="bg-white bg-opacity-20 p-2 rounded">
                                    <div class="w-full h-4 bg-white bg-opacity-40 rounded mb-1"></div>
                                    <div class="w-3/4 h-3 bg-white bg-opacity-30 rounded"></div>
                                </div>
                                <div class="bg-white bg-opacity-20 p-2 rounded">
                                    <div class="w-full h-4 bg-white bg-opacity-40 rounded mb-1"></div>
                                    <div class="w-3/4 h-3 bg-white bg-opacity-30 rounded"></div>
                                </div>
                                <div class="bg-white bg-opacity-20 p-2 rounded">
                                    <div class="w-full h-4 bg-white bg-opacity-40 rounded mb-1"></div>
                                    <div class="w-3/4 h-3 bg-white bg-opacity-30 rounded"></div>
                                </div>
                                <div class="bg-white bg-opacity-20 p-2 rounded">
                                    <div class="w-full h-4 bg-white bg-opacity-40 rounded mb-1"></div>
                                    <div class="w-3/4 h-3 bg-white bg-opacity-30 rounded"></div>
                                </div>
                            </div>
                            <div class="mt-4 bg-white bg-opacity-10 p-3 rounded">
                                <div class="flex justify-between mb-2">
                                    <div class="w-1/3 h-4 bg-white bg-opacity-30 rounded"></div>
                                    <div class="w-1/5 h-4 bg-white bg-opacity-30 rounded"></div>
                                </div>
                                <div class="w-full h-32 bg-white bg-opacity-5 rounded p-2">
                                    <div class="w-full h-4 bg-white bg-opacity-20 rounded mb-2"></div>
                                    <div class="w-4/5 h-3 bg-white bg-opacity-20 rounded mb-1"></div>
                                    <div class="w-3/5 h-3 bg-white bg-opacity-20 rounded mb-1"></div>
                                    <div class="w-2/3 h-3 bg-white bg-opacity-20 rounded"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="mt-4 flex flex-wrap gap-2 justify-center">
                    <button class="control-btn bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 py-1 px-3 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed" disabled>Mouse</button>
                    <button class="control-btn bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 py-1 px-3 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed" disabled>Keyboard</button>
                    <button class="control-btn bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 py-1 px-3 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed" disabled>File Transfer</button>
                    <button class="control-btn bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 py-1 px-3 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed" disabled>Screen Capture</button>
                    <button class="control-btn bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 py-1 px-3 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed" disabled>Clipboard</button>
                </div>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
            <!-- Server Code -->
            <div class="bg-light-card dark:bg-dark-card p-4 rounded-lg shadow-md border border-light-border dark:border-dark-border">
                <h2 class="text-xl font-semibold mb-4">Server Code (Target Computer)</h2>
                <div id="server-editor" class="h-[350px] w-full rounded border border-gray-300 dark:border-gray-600"></div>
            </div>

            <!-- Client Code -->
            <div class="bg-light-card dark:bg-dark-card p-4 rounded-lg shadow-md border border-light-border dark:border-dark-border">
                <h2 class="text-xl font-semibold mb-4">Client Code (Controller Computer)</h2>
                <div id="client-editor" class="h-[350px] w-full rounded border border-gray-300 dark:border-gray-600"></div>
            </div>
        </div>

        <div class="bg-light-card dark:bg-dark-card p-4 rounded-lg shadow-md border border-light-border dark:border-dark-border mb-8">
            <h2 class="text-xl font-semibold mb-4">Remote Control Log</h2>
            <div id="log" class="bg-gray-100 dark:bg-gray-800 p-3 rounded font-mono text-sm h-[150px] overflow-y-auto">
                <div class="log-entry text-gray-500">[System] Remote control software initialized</div>
            </div>
        </div>

        <div class="bg-light-card dark:bg-dark-card p-6 rounded-lg shadow-md border border-light-border dark:border-dark-border">
            <h2 class="text-xl font-semibold mb-4">How It Works</h2>
            <div id="explanation" class="prose dark:prose-invert max-w-none">
                <h3>Python Remote Control System Architecture</h3>
                <p>This demo showcases a Python-based remote control system with two main components:</p>
                <ul>
                    <li><strong>Server:</strong> Runs on the target computer (the one being controlled)</li>
                    <li><strong>Client:</strong> Runs on the controlling computer</li>
                </ul>
                
                <h3>Key Features</h3>
                <ul>
                    <li><strong>Screen Sharing:</strong> Captures and streams desktop screen</li>
                    <li><strong>Input Control:</strong> Sends mouse and keyboard events</li>
                    <li><strong>File Transfer:</strong> Securely transfers files between computers</li>
                    <li><strong>Security:</strong> Implements encryption and authentication</li>
                </ul>
                
                <h3>Technologies Used</h3>
                <ul>
                    <li><strong>Python:</strong> Core programming language</li>
                    <li><strong>Socket Programming:</strong> Network communication between client and server</li>
                    <li><strong>PyAutoGUI:</strong> For simulating mouse and keyboard input</li>
                    <li><strong>Pillow/OpenCV:</strong> For screen capture and image processing</li>
                    <li><strong>Threading:</strong> For concurrent operations</li>
                    <li><strong>Cryptography:</strong> For secure communication</li>
                </ul>
                
                <p>To use this in a real environment, both computers would need to have Python installed along with the necessary libraries. The server script would run on the target computer, while the client script would run on the controlling computer.</p>
            </div>
        </div>
    </div>

    <script>
        // Setup code editors
        const serverEditor = ace.edit("server-editor");
        serverEditor.setTheme("ace/theme/monokai");
        serverEditor.session.setMode("ace/mode/python");
        serverEditor.setReadOnly(true);
        serverEditor.setFontSize(14);

        const clientEditor = ace.edit("client-editor");
        clientEditor.setTheme("ace/theme/monokai");
        clientEditor.session.setMode("ace/mode/python");
        clientEditor.setReadOnly(true);
        clientEditor.setFontSize(14);

        // Server code
        const serverCode = `import socket
import threading
import pyautogui
import numpy as np
import cv2
import base64
import json
import os
from cryptography.fernet import Fernet
from time import sleep

class RemoteServer:
    def __init__(self, host='0.0.0.0', port=5000, password='secure_password'):
        self.host = host
        self.port = port
        self.password = password
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        
        # Generate encryption key from password
        key = base64.urlsafe_b64encode(password.ljust(32)[:32].encode())
        self.cipher = Fernet(key)
        
        # Screen dimensions
        self.screen_width, self.screen_height = pyautogui.size()
        
        self.clients = []
        self.running = True
    
    def start(self):
        """Start the server and listen for connections"""
        self.socket.bind((self.host, self.port))
        self.socket.listen(5)
        print(f"Server started on {self.host}:{self.port}")
        
        # Start accepting clients
        accept_thread = threading.Thread(target=self.accept_clients)
        accept_thread.daemon = True
        accept_thread.start()
        
        try:
            while self.running:
                sleep(1)
        except KeyboardInterrupt:
            self.shutdown()
    
    def accept_clients(self):
        """Accept connection requests from clients"""
        while self.running:
            try:
                client_socket, addr = self.socket.accept()
                print(f"Connection from {addr}")
                
                # Start a new thread to handle the client
                client_thread = threading.Thread(
                    target=self.handle_client,
                    args=(client_socket, addr)
                )
                client_thread.daemon = True
                client_thread.start()
                
            except Exception as e:
                print(f"Error accepting client: {e}")
    
    def handle_client(self, client_socket, addr):
        """Handle communication with a connected client"""
        try:
            # Authentication
            if not self.authenticate_client(client_socket):
                print(f"Authentication failed for {addr}")
                client_socket.close()
                return
            
            print(f"Client {addr} authenticated successfully")
            self.clients.append(client_socket)
            
            # Main communication loop
            while self.running:
                # Receive encrypted command
                encrypted_data = client_socket.recv(4096)
                if not encrypted_data:
                    break
                
                # Decrypt command
                data = self.cipher.decrypt(encrypted_data).decode()
                cmd = json.loads(data)
                
                # Process command
                if cmd['action'] == 'screen':
                    self.send_screen(client_socket)
                elif cmd['action'] == 'mouse':
                    self.handle_mouse(cmd)
                elif cmd['action'] == 'keyboard':
                    self.handle_keyboard(cmd)
                elif cmd['action'] == 'file_download':
                    self.send_file(client_socket, cmd['path'])
                elif cmd['action'] == 'file_upload':
                    self.receive_file(client_socket, cmd['path'], cmd['size'])
        except Exception as e:
            print(f"Error handling client {addr}: {e}")
        finally:
            if client_socket in self.clients:
                self.clients.remove(client_socket)
            client_socket.close()
            print(f"Connection closed for {addr}")
    
    def authenticate_client(self, client_socket):
        """Verify client password"""
        try:
            # Receive encrypted authentication request
            auth_data = client_socket.recv(1024)
            decrypted = self.cipher.decrypt(auth_data).decode()
            auth = json.loads(decrypted)
            
            # Verify password
            if auth.get('password') == self.password:
                response = {'status': 'success'}
                encrypted = self.cipher.encrypt(json.dumps(response).encode())
                client_socket.send(encrypted)
                return True
            else:
                response = {'status': 'failed', 'reason': 'Invalid password'}
                encrypted = self.cipher.encrypt(json.dumps(response).encode())
                client_socket.send(encrypted)
                return False
        except Exception as e:
            print(f"Authentication error: {e}")
            return False
    
    def send_screen(self, client_socket):
        """Capture and send screen to client"""
        # Capture screen
        screenshot = pyautogui.screenshot()
        screenshot = np.array(screenshot)
        
        # Compress image
        _, buffer = cv2.imencode('.jpg', screenshot, [cv2.IMWRITE_JPEG_QUALITY, 40])
        jpg_as_text = base64.b64encode(buffer).decode()
        
        # Send screen data
        screen_data = {
            'width': self.screen_width,
            'height': self.screen_height,
            'image': jpg_as_text
        }
        
        encrypted = self.cipher.encrypt(json.dumps(screen_data).encode())
        
        # Send size first, then data
        size = len(encrypted)
        client_socket.send(size.to_bytes(4, byteorder='big'))
        client_socket.send(encrypted)
    
    def handle_mouse(self, cmd):
        """Process mouse commands"""
        if cmd['type'] == 'move':
            pyautogui.moveTo(cmd['x'], cmd['y'])
        elif cmd['type'] == 'click':
            pyautogui.click(cmd['x'], cmd['y'], button=cmd['button'])
        elif cmd['type'] == 'double_click':
            pyautogui.doubleClick(cmd['x'], cmd['y'], button=cmd['button'])
        elif cmd['type'] == 'drag':
            pyautogui.dragTo(cmd['x'], cmd['y'], button=cmd['button'])
        elif cmd['type'] == 'scroll':
            pyautogui.scroll(cmd['amount'])
    
    def handle_keyboard(self, cmd):
        """Process keyboard commands"""
        if cmd['type'] == 'key':
            pyautogui.press(cmd['key'])
        elif cmd['type'] == 'hotkey':
            pyautogui.hotkey(*cmd['keys'])
        elif cmd['type'] == 'write':
            pyautogui.write(cmd['text'])
    
    def send_file(self, client_socket, path):
        """Send file to client"""
        try:
            with open(path, 'rb') as file:
                file_data = file.read()
            
            # Send file size
            size = len(file_data)
            size_data = {'size': size}
            encrypted = self.cipher.encrypt(json.dumps(size_data).encode())
            client_socket.send(encrypted)
            
            # Send file data (in chunks)
            chunk_size = 4096
            for i in range(0, len(file_data), chunk_size):
                chunk = file_data[i:i+chunk_size]
                encrypted_chunk = self.cipher.encrypt(chunk)
                client_socket.send(encrypted_chunk)
        except Exception as e:
            print(f"Error sending file: {e}")
    
    def receive_file(self, client_socket, path, size):
        """Receive file from client"""
        try:
            # Create directory if it doesn't exist
            directory = os.path.dirname(path)
            if directory and not os.path.exists(directory):
                os.makedirs(directory)
            
            # Receive file data
            with open(path, 'wb') as file:
                received = 0
                while received < size:
                    encrypted_chunk = client_socket.recv(4096)
                    if not encrypted_chunk:
                        break
                    
                    chunk = self.cipher.decrypt(encrypted_chunk)
                    file.write(chunk)
                    received += len(chunk)
            
            # Send confirmation
            response = {'status': 'success'}
            encrypted = self.cipher.encrypt(json.dumps(response).encode())
            client_socket.send(encrypted)
        except Exception as e:
            print(f"Error receiving file: {e}")
            response = {'status': 'error', 'message': str(e)}
            encrypted = self.cipher.encrypt(json.dumps(response).encode())
            client_socket.send(encrypted)
    
    def shutdown(self):
        """Stop the server"""
        self.running = False
        for client in self.clients:
            try:
                client.close()
            except:
                pass
        self.socket.close()
        print("Server shutdown")

if __name__ == "__main__":
    server = RemoteServer()
    server.start()`;

        // Client code
        const clientCode = `import socket
import threading
import base64
import json
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import cv2
import numpy as np
from PIL import Image, ImageTk
import os
from cryptography.fernet import Fernet
from io import BytesIO

class RemoteClient:
    def __init__(self, host='localhost', port=5000, password='secure_password'):
        self.host = host
        self.port = port
        self.password = password
        self.socket = None
        self.connected = False
        
        # Generate encryption key from password
        key = base64.urlsafe_b64encode(password.ljust(32)[:32].encode())
        self.cipher = Fernet(key)
        
        # Set up the GUI
        self.setup_gui()
    
    def setup_gui(self):
        """Create the GUI interface"""
        self.root = tk.Tk()
        self.root.title("Python Remote Control Client")
        self.root.geometry("1200x800")
        
        # Create main frame
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Connection frame (left side)
        conn_frame = ttk.LabelFrame(main_frame, text="Connection")
        conn_frame.pack(side=tk.LEFT, fill=tk.Y, padx=5, pady=5)
        
        # Host input
        ttk.Label(conn_frame, text="Host:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.host_var = tk.StringVar(value=self.host)
        ttk.Entry(conn_frame, textvariable=self.host_var, width=20).grid(row=0, column=1, pady=5)
        
        # Port input
        ttk.Label(conn_frame, text="Port:").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.port_var = tk.IntVar(value=self.port)
        ttk.Entry(conn_frame, textvariable=self.port_var, width=20).grid(row=1, column=1, pady=5)
        
        # Password input
        ttk.Label(conn_frame, text="Password:").grid(row=2, column=0, sticky=tk.W, pady=5)
        self.password_var = tk.StringVar(value=self.password)
        ttk.Entry(conn_frame, textvariable=self.password_var, show="*", width=20).grid(row=2, column=1, pady=5)
        
        # Connect button
        self.connect_btn = ttk.Button(conn_frame, text="Connect", command=self.connect)
        self.connect_btn.grid(row=3, column=0, columnspan=2, pady=10)
        
        # Status label
        self.status_var = tk.StringVar(value="Disconnected")
        status_label = ttk.Label(conn_frame, textvariable=self.status_var, foreground="red")
        status_label.grid(row=4, column=0, columnspan=2, pady=5)
        
        # File transfer frame
        file_frame = ttk.LabelFrame(conn_frame, text="File Transfer")
        file_frame.grid(row=5, column=0, columnspan=2, sticky=tk.EW, pady=10)
        
        # Upload button
        self.upload_btn = ttk.Button(file_frame, text="Upload File", command=self.upload_file, state=tk.DISABLED)
        self.upload_btn.pack(fill=tk.X, pady=5)
        
        # Download button
        self.download_btn = ttk.Button(file_frame, text="Download File", command=self.download_file, state=tk.DISABLED)
        self.download_btn.pack(fill=tk.X, pady=5)
        
        # Screen display frame (right side)
        screen_frame = ttk.LabelFrame(main_frame, text="Remote Screen")
        screen_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Canvas for screen display
        self.canvas = tk.Canvas(screen_frame, bg="black")
        self.canvas.pack(fill=tk.BOTH, expand=True)
        
        # Bind mouse events to canvas
        self.canvas.bind("<Button-1>", self.on_mouse_click)
        self.canvas.bind("<Double-Button-1>", self.on_mouse_double_click)
        self.canvas.bind("<B1-Motion>", self.on_mouse_drag)
        self.canvas.bind("<ButtonRelease-1>", self.on_mouse_release)
        self.canvas.bind("<MouseWheel>", self.on_mouse_wheel)
        self.canvas.bind("<Motion>", self.on_mouse_move)
        
        # Bind keyboard events to root window
        self.root.bind("<Key>", self.on_key_press)
        
        # Set up screen update thread
        self.screen_thread = None
        self.screen_running = False
        
        # Remote screen dimensions
        self.remote_width = 0
        self.remote_height = 0
        
        # Protocol handler for window close
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)
    
    def connect(self):
        """Connect to the remote server"""
        try:
            # Get connection details from GUI
            self.host = self.host_var.get()
            self.port = self.port_var.get()
            self.password = self.password_var.get()
            
            # Create socket and connect
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.connect((self.host, self.port))
            
            # Authenticate
            if self.authenticate():
                self.connected = True
                self.status_var.set("Connected")
                
                # Update button states
                self.connect_btn.configure(text="Disconnect", command=self.disconnect)
                self.upload_btn.configure(state=tk.NORMAL)
                self.download_btn.configure(state=tk.NORMAL)
                
                # Start screen updates
                self.screen_running = True
                self.screen_thread = threading.Thread(target=self.update_screen)
                self.screen_thread.daemon = True
                self.screen_thread.start()
            else:
                messagebox.showerror("Authentication Failed", "Invalid password")
                self.socket.close()
                self.socket = None
        except Exception as e:
            messagebox.showerror("Connection Error", str(e))
            if self.socket:
                self.socket.close()
                self.socket = None
    
    def authenticate(self):
        """Authenticate with the server"""
        auth_data = {'password': self.password}
        encrypted = self.cipher.encrypt(json.dumps(auth_data).encode())
        self.socket.send(encrypted)
        
        # Receive response
        response_data = self.socket.recv(1024)
        decrypted = self.cipher.decrypt(response_data).decode()
        response = json.loads(decrypted)
        
        return response.get('status') == 'success'
    
    def disconnect(self):
        """Disconnect from the server"""
        self.screen_running = False
        if self.socket:
            self.socket.close()
            self.socket = None
        
        self.connected = False
        self.status_var.set("Disconnected")
        
        # Update button states
        self.connect_btn.configure(text="Connect", command=self.connect)
        self.upload_btn.configure(state=tk.DISABLED)
        self.download_btn.configure(state=tk.DISABLED)
    
    def update_screen(self):
        """Request and display screen updates from server"""
        while self.screen_running and self.connected:
            try:
                # Request screen update
                cmd = {'action': 'screen'}
                encrypted = self.cipher.encrypt(json.dumps(cmd).encode())
                self.socket.send(encrypted)
                
                # Receive data size
                size_bytes = self.socket.recv(4)
                size = int.from_bytes(size_bytes, byteorder='big')
                
                # Receive screen data
                data = b''
                while len(data) < size:
                    chunk = self.socket.recv(min(size - len(data), 4096))
                    if not chunk:
                        break
                    data += chunk
                
                if not data:
                    break
                
                # Decrypt and parse screen data
                decrypted = self.cipher.decrypt(data).decode()
                screen_data = json.loads(decrypted)
                
                # Update remote screen dimensions
                self.remote_width = screen_data['width']
                self.remote_height = screen_data['height']
                
                # Decode image
                image_data = base64.b64decode(screen_data['image'])
                image_array = np.frombuffer(image_data, dtype=np.uint8)
                image = cv2.imdecode(image_array, cv2.IMREAD_COLOR)
                image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
                
                # Resize image to fit canvas
                canvas_width = self.canvas.winfo_width()
                canvas_height = self.canvas.winfo_height()
                
                if canvas_width > 1 and canvas_height > 1:
                    # Calculate aspect ratio
                    img_ratio = self.remote_width / self.remote_height
                    canvas_ratio = canvas_width / canvas_height
                    
                    if img_ratio > canvas_ratio:
                        # Fit to width
                        new_width = canvas_width
                        new_height = int(canvas_width / img_ratio)
                    else:
                        # Fit to height
                        new_height = canvas_height
                        new_width = int(canvas_height * img_ratio)
                    
                    image = cv2.resize(image, (new_width, new_height))
                
                # Convert to PhotoImage and display
                pil_img = Image.fromarray(image)
                tk_img = ImageTk.PhotoImage(pil_img)
                
                # Update canvas
                self.canvas.config(width=tk_img.width(), height=tk_img.height())
                self.canvas.create_image(0, 0, anchor=tk.NW, image=tk_img)
                self.canvas.image = tk_img  # Keep reference to prevent garbage collection
            
            except Exception as e:
                print(f"Screen update error: {e}")
                break
        
        if self.connected:
            self.disconnect()
    
    def map_coordinates(self, x, y):
        """Map canvas coordinates to remote screen coordinates"""
        canvas_width = self.canvas.winfo_width()
        canvas_height = self.canvas.winfo_height()
        
        if canvas_width <= 1 or canvas_height <= 1:
            return x, y
        
        remote_x = int((x / canvas_width) * self.remote_width)
        remote_y = int((y / canvas_height) * self.remote_height)
        
        return remote_x, remote_y
    
    def on_mouse_click(self, event):
        """Handle mouse click event"""
        if not self.connected:
            return
        
        x, y = self.map_coordinates(event.x, event.y)
        cmd = {
            'action': 'mouse',
            'type': 'click',
            'x': x,
            'y': y,
            'button': 'left'
        }
        
        encrypted = self.cipher.encrypt(json.dumps(cmd).encode())
        self.socket.send(encrypted)
    
    def on_mouse_double_click(self, event):
        """Handle mouse double click event"""
        if not self.connected:
            return
        
        x, y = self.map_coordinates(event.x, event.y)
        cmd = {
            'action': 'mouse',
            'type': 'double_click',
            'x': x,
            'y': y,
            'button': 'left'
        }
        
        encrypted = self.cipher.encrypt(json.dumps(cmd).encode())
        self.socket.send(encrypted)
    
    def on_mouse_drag(self, event):
        """Handle mouse drag event"""
        if not self.connected:
            return
        
        x, y = self.map_coordinates(event.x, event.y)
        cmd = {
            'action': 'mouse',
            'type': 'move',
            'x': x,
            'y': y
        }
        
        encrypted = self.cipher.encrypt(json.dumps(cmd).encode())
        self.socket.send(encrypted)
    
    def on_mouse_release(self, event):
        """Handle mouse release event"""
        pass  # We might need this for drag operations
    
    def on_mouse_wheel(self, event):
        """Handle mouse wheel event"""
        if not self.connected:
            return
        
        # In Windows, event.delta is used
        amount = event.delta // 120
        
        cmd = {
            'action': 'mouse',
            'type': 'scroll',
            'amount': amount
        }
        
        encrypted = self.cipher.encrypt(json.dumps(cmd).encode())
        self.socket.send(encrypted)
    
    def on_mouse_move(self, event):
        """Handle mouse movement event"""
        if not self.connected:
            return
        
        x, y = self.map_coordinates(event.x, event.y)
        cmd = {
            'action': 'mouse',
            'type': 'move',
            'x': x,
            'y': y
        }
        
        encrypted = self.cipher.encrypt(json.dumps(cmd).encode())
        self.socket.send(encrypted)
    
    def on_key_press(self, event):
        """Handle key press event"""
        if not self.connected:
            return
        
        # Get the key name
        key = event.keysym
        
        # Special handling for modifier keys
        if key in ('Control_L', 'Control_R', 'Alt_L', 'Alt_R', 'Shift_L', 'Shift_R'):
            return
        
        # Check if any modifiers are pressed
        modifiers = []
        if event.state & 0x4:  # Control
            modifiers.append('ctrl')
        if event.state & 0x8:  # Alt
            modifiers.append('alt')
        if event.state & 0x1:  # Shift
            modifiers.append('shift')
        
        if modifiers:
            # Send hotkey command
            cmd = {
                'action': 'keyboard',
                'type': 'hotkey',
                'keys': modifiers + [key.lower()]
            }
        else:
            # Send single key command
            cmd = {
                'action': 'keyboard',
                'type': 'key',
                'key': key.lower()
            }
        
        encrypted = self.cipher.encrypt(json.dumps(cmd).encode())
        self.socket.send(encrypted)
    
    def upload_file(self):
        """Upload a file to the remote computer"""
        if not self.connected:
            messagebox.showerror("Error", "Not connected to server")
            return
        
        # Open file dialog
        file_path = filedialog.askopenfilename()
        if not file_path:
            return
        
        # Ask for remote path
        remote_path = filedialog.asksaveasfilename(title="Save as on remote computer")
        if not remote_path:
            return
        
        try:
            # Get file size
            file_size = os.path.getsize(file_path)
            
            # Send file upload command
            cmd = {
                'action': 'file_upload',
                'path': remote_path,
                'size': file_size
            }
            
            encrypted = self.cipher.encrypt(json.dumps(cmd).encode())
            self.socket.send(encrypted)
            
            # Read and send file data
            with open(file_path, 'rb') as file:
                chunk_size = 4096
                while True:
                    chunk = file.read(chunk_size)
                    if not chunk:
                        break
                    
                    encrypted_chunk = self.cipher.encrypt(chunk)
                    self.socket.send(encrypted_chunk)
            
            # Receive confirmation
            response_data = self.socket.recv(1024)
            decrypted = self.cipher.decrypt(response_data).decode()
            response = json.loads(decrypted)
            
            if response.get('status') == 'success':
                messagebox.showinfo("Success", "File uploaded successfully")
            else:
                messagebox.showerror("Error", response.get('message', 'Unknown error'))
        
        except Exception as e:
            messagebox.showerror("Upload Error", str(e))
    
    def download_file(self):
        """Download a file from the remote computer"""
        if not self.connected:
            messagebox.showerror("Error", "Not connected to server")
            return
        
        # Ask for remote path
        remote_path = simpledialog.askstring("Download File", "Enter remote file path:")
        if not remote_path:
            return
        
        # Ask for local save path
        local_path = filedialog.asksaveasfilename(title="Save file locally as")
        if not local_path:
            return
        
        try:
            # Send file download command
            cmd = {
                'action': 'file_download',
                'path': remote_path
            }
            
            encrypted = self.cipher.encrypt(json.dumps(cmd).encode())
            self.socket.send(encrypted)
            
            # Receive file size
            size_data = self.socket.recv(1024)
            decrypted = self.cipher.decrypt(size_data).decode()
            size_info = json.loads(decrypted)
            
            if 'error' in size_info:
                messagebox.showerror("Error", size_info['error'])
                return
            
            file_size = size_info['size']
            
            # Receive file data
            with open(local_path, 'wb') as file:
                received = 0
                while received < file_size:
                    chunk = self.socket.recv(4096)
                    if not chunk:
                        break
                    
                    decrypted_chunk = self.cipher.decrypt(chunk)
                    file.write(decrypted_chunk)
                    received += len(decrypted_chunk)
            
            messagebox.showinfo("Success", "File downloaded successfully")
        
        except Exception as e:
            messagebox.showerror("Download Error", str(e))
    
    def run(self):
        """Run the application"""
        self.root.mainloop()
    
    def on_close(self):
        """Handle window close event"""
        if self.connected:
            self.disconnect()
        self.root.destroy()

if __name__ == "__main__":
    client = RemoteClient()
    client.run()`;

        serverEditor.setValue(serverCode);
        clientEditor.setValue(clientCode);
        serverEditor.clearSelection();
        clientEditor.clearSelection();

        // Parse Markdown in explanation
        document.getElementById('explanation').innerHTML = marked.parse(document.getElementById('explanation').innerHTML);

        // Setup event listeners
        const connectBtn = document.getElementById('connect-btn');
        const connectionStatus = document.getElementById('connection-status');
        const controlBtns = document.querySelectorAll('.control-btn');
        const remoteDesktop = document.getElementById('remote-desktop');
        const screenMessage = document.getElementById('screen-message');
        
        connectBtn.addEventListener('click', function() {
            if (this.textContent === 'Connect') {
                // Simulate connection
                connectionStatus.textContent = 'Connecting...';
                connectionStatus.className = 'text-sm font-medium text-yellow-500 mt-2';
                
                // Disable the button during "connection"
                this.disabled = true;
                
                // Simulate connection delay
                setTimeout(() => {
                    connectionStatus.textContent = 'Connected';
                    connectionStatus.className = 'text-sm font-medium text-green-500 mt-2';
                    this.textContent = 'Disconnect';
                    this.disabled = false;
                    
                    // Enable control buttons
                    controlBtns.forEach(btn => btn.disabled = false);
                    
                    // Show remote desktop
                    screenMessage.classList.add('hidden');
                    remoteDesktop.classList.remove('hidden');
                    
                    // Add log entry
                    addLogEntry('Connection established to ' + document.getElementById('host').value);
                }, 1500);
            } else {
                // Disconnect
                connectionStatus.textContent = 'Disconnected';
                connectionStatus.className = 'text-sm font-medium text-red-500 mt-2';
                this.textContent = 'Connect';
                
                // Disable control buttons
                controlBtns.forEach(btn => btn.disabled = true);
                
                // Hide remote desktop
                screenMessage.classList.remove('hidden');
                remoteDesktop.classList.add('hidden');
                
                // Add log entry
                addLogEntry('Disconnected from remote host');
            }
        });
        
        // Simulate control button actions
        controlBtns.forEach(btn => {
            btn.addEventListener('click', function() {
                const action = this.textContent.toLowerCase();
                addLogEntry(`Sending ${action} command to remote host`);
            });
        });
        
        // Function to add log entries
        function addLogEntry(message) {
            const log = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `[${timestamp}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }
    </script>
</body>
</html>